<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>SummitAI ‚Äî Minimal AI assisted meets platform</title>
  <style>
    :root {
      --primary: #1a73e8;
      --primary-dark: #155ab6;
      --danger: #e84545;
      --bg: #f7f9fc;
      --card-bg: #ffffff;
      --text: #202124;
      --border: #dadce0;
      --radius: 10px;
      --transition: 0.25s ease;
    }

    body {
      font-family: "Inter", "Segoe UI", Roboto, sans-serif;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h2 {
      margin-top: 1.2em;
      color: var(--primary-dark);
      letter-spacing: 0.5px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5em;
      margin: 1em 0;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 1em 1.5em;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
    }

    #controls input {
      padding: 0.6em 1em;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 0.95em;
      width: 180px;
    }

    button {
      border: none;
      padding: 0.6em 1.2em;
      font-size: 0.95em;
      border-radius: var(--radius);
      cursor: pointer;
      transition: var(--transition);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #join {
      background: var(--primary);
      color: #fff;
    }

    #join:hover:not(:disabled) {
      background: var(--primary-dark);
    }

    #leave {
      background: var(--danger);
      color: #fff;
    }

    #leave:hover:not(:disabled) {
      background: #c73030;
    }

    #mute,
    #video {
      background: #f1f3f4;
      color: var(--text);
    }

    #mute:hover,
    #video:hover {
      background: #e0e3e7;
    }

    #finalize {
      margin-top: 1em;
      margin-bottom: 1rem;
      background: #0f9d58;
      color: #fff;
    }

    #finalize:hover:not(:disabled) {
      background: #0c7a44;
    }

    #videos {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 1em;
      width: 100%;
      max-width: 900px;
      margin-top: 1em;
    }

    video {
      width: 45%;
      max-width: 420px;
      border-radius: var(--radius);
      background: #000;
      border: 2px solid var(--border);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      transition: var(--transition);
    }

    video:hover {
      transform: scale(1.02);
      border-color: var(--primary);
    }

    #chat {
      width: 60%;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      margin-top: 1.5em;
      padding: 1em;
      height: 250px;
      overflow-y: auto;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
    }

    #chat div {
      padding: 0.4em 0.6em;
      margin-bottom: 0.4em;
      border-radius: 6px;
      font-size: 0.95em;
    }

    #chat div:nth-child(even) {
      background: #f8f9fa;
    }

    #chat div:nth-child(odd) {
      background: #eef6ff;
    }

    #chat-input {
      width: 60%;
      margin-top: 0.5em;
      display: flex;
      gap: 0.5em;
    }

    #chat-input input {
      flex: 1;
      padding: 0.6em 1em;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      font-size: 0.95em;
    }

    #chat-input button {
      background: var(--primary);
      color: #fff;
    }

    #chat-input button:hover {
      background: var(--primary-dark);
    }

    #summary {
      width: 60%;
      background: #e8f6ff;
      border-radius: var(--radius);
      padding: 1.2em;
      margin-top: 1.5em;
      border: 1px solid #bce0fd;
      display: none;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
    }

    #summary pre {
      background: #fff;
      padding: 0.8em;
      border-radius: 6px;
      white-space: pre-wrap;
      word-wrap: break-word;
      border: 1px solid #dbe5f0;
      font-family: monospace;
      font-size: 0.9em;
    }

    #chat::-webkit-scrollbar {
      width: 8px;
    }

    #chat::-webkit-scrollbar-thumb {
      background: #c3c8ce;
      border-radius: 8px;
    }

    #chat::-webkit-scrollbar-thumb:hover {
      background: #a8adb3;
    }
  </style>
</head>

<body>
  <h2>SummitAI</h2>

  <div id="controls">
    <input id="room" placeholder="Room ID" />
    <button id="join">Join Room</button>
    <button id="leave" disabled>Leave</button>

    <button id="mute" disabled>Mute</button>
    <button id="video" disabled>Turn Off Video</button>
  </div>

  <div id="videos">
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

  <div id="chat"></div>

  <div id="chat-input">
    <input id="chatText" placeholder="Type a message..." />
    <button id="send">Send</button>
  </div>

  <button id="finalize" disabled>End Meeting & Summarize</button>

  <div id="summary"></div>

  <script type="module">
    import { io } from "https://cdn.socket.io/4.7.1/socket.io.esm.min.js";
    const BASE_URL = location.origin;
    const roomInput = document.getElementById("room");
    const joinBtn = document.getElementById("join");
    const leaveBtn = document.getElementById("leave");
    const finalizeBtn = document.getElementById("finalize");
    const sendBtn = document.getElementById("send");
    const chatInput = document.getElementById("chatText");
    const chatBox = document.getElementById("chat");
    const summaryBox = document.getElementById("summary");
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const muteBtn = document.getElementById("mute");
    const videoBtn = document.getElementById("video");

    const peers = {}; // { peerId: RTCPeerConnection }
    // const localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });


    let ws, pc, clientId;
    let currentRoomId = null;
    let isMuted = false;
    let isVideoOff = false;

    const socket = io();


    socket.on("connect", () => {
      clientId = socket.id;
      console.log("Connected with clientId:", clientId);
    });


    joinBtn.onclick = async () => {
      const room = roomInput.value.trim();
      if (!room) return alert("Enter room ID");
      navigator.mediaDevices.enumerateDevices().then(devices => {
        console.log(devices.filter(d => d.kind === "audioinput"));
      });


      const localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: { deviceId: "default" } });
      window.localStream = localStream;

      currentRoomId = room;

      joinBtn.disabled = true;
      leaveBtn.disabled = false;
      finalizeBtn.disabled = false;
      muteBtn.disabled = false;
      videoBtn.disabled = false;

      localVideo.srcObject = localStream;
      socket.emit("join", { room });
      startRecording(room);
    };


    socket.on("new-peer", async ({ peer }) => {
      const pc = createPeerConnection(peer);
      peers[peer] = pc;
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit("signal", { target: peer, data: { type: "offer", sdp: offer.sdp } });
    });

    socket.on("existing-peer", async ({ peer }) => {
      const pc = createPeerConnection(peer);
      peers[peer] = pc;
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
    });

    socket.on("signal", async ({ from, data }) => {
      let pc = peers[from];
      if (!pc) pc = createPeerConnection(from);

      if (data.type === "offer") {
        await pc.setRemoteDescription({ type: "offer", sdp: data.sdp });
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit("signal", { target: from, data: { type: "answer", sdp: answer.sdp } });
      } else if (data.type === "answer") {
        await pc.setRemoteDescription({ type: "answer", sdp: data.sdp });
      } else if (data.candidate) {
        try { await pc.addIceCandidate(data.candidate); } catch (e) { console.error(e); }
      }
    });


    function createPeerConnection(peerId) {
      const pc = new RTCPeerConnection();

      pc.onicecandidate = event => {
        if (event.candidate) {
          socket.emit("signal", { target: peerId, data: { candidate: event.candidate } });
        }
      };

      pc.ontrack = event => {
        addRemoteVideo(peerId, event.streams[0]);
      };

      return pc;
    }

    function addRemoteVideo(peerId, stream) {
      // if (peerId === myPeerId) return;
      let video = document.getElementById(`video-${peerId}`);
      if (!video) {
        video = document.createElement("video");
        video.id = `video-${peerId}`;
        video.autoplay = true;
        video.playsInline = true;
        document.getElementById("videos").appendChild(video);
      }
      video.srcObject = stream;
    }

    socket.on("peer-left", ({ peer }) => {
      const video = document.getElementById(`video-${peer}`);
      if (video) video.remove();
      if (peers[peer]) {
        peers[peer].close();
        delete peers[peer];
      }
    });


    function addChatMessage(from, msg) {
      const msgElement = document.createElement("div");
      msgElement.textContent = from + ": " + msg;
      msgElement.style.marginBottom = "4px";
      chatBox.appendChild(msgElement);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    let mediaRecorder;

    // async function startRecording(roomId) {
    //   try {
    //     const audioStream = new MediaStream(localStream.getAudioTracks());
    //     let mimeType = "";
    //     if (MediaRecorder.isTypeSupported("audio/webm;codecs=opus")) mimeType = "audio/webm;codecs=opus";
    //     else if (MediaRecorder.isTypeSupported("audio/webm")) mimeType = "audio/webm";
    //     else if (MediaRecorder.isTypeSupported("audio/ogg;codecs=opus")) mimeType = "audio/ogg;codecs=opus";

    //     mediaRecorder = new MediaRecorder(audioStream, mimeType ? { mimeType } : {});
    //     mediaRecorder.ondataavailable = async (e) => {
    //       if (e.data.size > 0) await uploadChunk(e.data, roomId);
    //     };
    //     mediaRecorder.start(15000);
    //     console.log("üéôÔ∏è Recording started");
    //   } catch (err) {
    //     console.error("‚ùå Failed to start MediaRecorder:", err);
    //   }
    // }

    async function startRecording(roomId) {
      try {
        // use the original localStream directly (which includes both video & audio)
        const audioTracks = localStream.getAudioTracks();
        if (!audioTracks.length) {
          console.warn("‚ö†Ô∏è No audio track found!");
          return;
        }

        const audioStream = new MediaStream(audioTracks);

        let options = {};
        if (MediaRecorder.isTypeSupported("audio/webm;codecs=opus")) {
          options = { mimeType: "audio/webm;codecs=opus" };
        } else if (MediaRecorder.isTypeSupported("audio/webm")) {
          options = { mimeType: "audio/webm" };
        } else if (MediaRecorder.isTypeSupported("audio/ogg;codecs=opus")) {
          options = { mimeType: "audio/ogg;codecs=opus" };
        }

        console.log("üéôÔ∏è Starting recorder with options:", options);

        mediaRecorder = new MediaRecorder(audioStream, options);

        mediaRecorder.ondataavailable = async (e) => {
          if (e.data && e.data.size > 5000) {
            console.log("üì¶ Audio chunk ready:", e.data.size, "bytes");
            await uploadChunk(e.data, roomId);
          }
        };

        mediaRecorder.onerror = (err) => console.error("Recorder error:", err);
        mediaRecorder.onstart = () => console.log("üéß MediaRecorder started");
        mediaRecorder.onstop = () => console.log("üõë MediaRecorder stopped");

        mediaRecorder.start(5000); // send chunks every 5s
        // mediaRecorder.start();

        // let flushTimer;
        // function scheduleFlush() {
        //   flushTimer = setTimeout(() => {
        //     if (mediaRecorder && mediaRecorder.state === "recording") {
        //       console.log("üîÑ Requesting data flush...");
        //       mediaRecorder.requestData();
        //       scheduleFlush();
        //     }
        //   }, 10000); // every 10s instead of 5s
        // }
        // scheduleFlush();

      } catch (err) {
        console.error("‚ùå Failed to start MediaRecorder:", err);
      }
    }


    // function stopRecording() {
    //   if (mediaRecorder && mediaRecorder.state !== "inactive") {
    //     mediaRecorder.stop();
    //   }
    // }

    async function stopRecording() {
      if (!mediaRecorder) return;
      console.log("üõë Stopping recorder...");

      if (mediaRecorder.state === "recording") {
        mediaRecorder.requestData(); // force flush last chunk
        await new Promise(r => setTimeout(r, 1000)); // wait 1s for blob event
        mediaRecorder.stop();
      }
    }


    // async function uploadChunk(blob, meetingId) {
    //   const form = new FormData();
    //   form.append("meeting_id", meetingId);
    //   form.append("chunk", blob, `chunk_${Date.now()}.webm`);
    //   try {
    //     const resp = await fetch(`${BASE_URL}/ai/upload_chunk/`, { method: "POST", body: form });
    //     const data = await resp.json();
    //     console.log("Uploaded chunk:", data);
    //   } catch (e) {
    //     console.error("Upload failed:", e);
    //   }
    // }

    async function uploadChunk(blob, meetingId) {
      const form = new FormData();
      form.append("meeting_id", meetingId);
      form.append("chunk", blob, `chunk_${Date.now()}.webm`);
      try {
        const resp = await fetch(`${BASE_URL}/ai/upload_chunk/`, { method: "POST", body: form });
        if (!resp.ok) {
          const text = await resp.text();
          console.error("‚ùå Upload failed:", resp.status, text);
          return;
        }
        const data = await resp.json();
        console.log("‚úÖ Uploaded chunk:", data);
      } catch (e) {
        console.error("‚ö†Ô∏è Upload error:", e);
      }
    }


    leaveBtn.onclick = () => {
      if (ws) ws.close();
      if (pc) pc.close();
      stopRecording();
      localStream.getTracks().forEach((t) => t.stop());
      joinBtn.disabled = false;
      leaveBtn.disabled = true;
      muteBtn.disabled = true;
      videoBtn.disabled = true;
    };

    async function sendChat(text) {
      const ts = Date.now() / 1000;
      const msg = { meeting_id: currentRoomId, sender: clientId, text, ts };
      try {
        await fetch(`${BASE_URL}/ai/log_chat/`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(msg),
        });
      } catch (e) {
        console.error("Chat send failed:", e);
      }
    }

    sendBtn.onclick = () => {
      const msg = chatInput.value.trim();
      if (msg && room) {
        sendChat(msg);
        socket.emit("chat", { room: currentRoomId, message: msg });
        chatInput.value = "";
      }
    };

    socket.on("chat", ({ from, message }) => {
      addChatMessage(from.substring(0, 5), message);
    });

    finalizeBtn.onclick = async () => {
      finalizeBtn.disabled = true;
      summaryBox.style.display = "block";
      summaryBox.textContent = "‚è≥ Generating AI summary...";
      try {
        const resp = await fetch(`${BASE_URL}/ai/finalize/?meeting_id=${currentRoomId}`, { method: "POST" });
        const data = await resp.json();
        if (data.summary) {
          summaryBox.innerHTML = `<h3>Meeting Summary</h3><pre>${data.summary}</pre>`;
        } else {
          summaryBox.textContent = "‚ö†Ô∏è Could not generate summary.";
        }
      } catch (err) {
        summaryBox.textContent = "‚ùå Error finalizing meeting.";
        console.error(err);
      }
    };

    muteBtn.onclick = () => {
      isMuted = !isMuted;
      localStream.getAudioTracks().forEach((track) => (track.enabled = !isMuted));
      muteBtn.textContent = isMuted ? "Unmute" : "Mute";
    };

    videoBtn.onclick = () => {
      isVideoOff = !isVideoOff;
      localStream.getVideoTracks().forEach((track) => (track.enabled = !isVideoOff));
      videoBtn.textContent = isVideoOff ? "Turn On Video" : "Turn Off Video";
    };
  </script>
</body>

</html>